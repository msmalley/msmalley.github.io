<!DOCTYPE html>
<html>
    
    <head>
        
        <!-- META -->
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
        <link rel='dns-prefetch' href='//s.w.org' />
        <title>CORTEX JS</title>
        
        <!-- STYLES -->
        <link rel="stylesheet" href="css/mvp.css">
        <link rel="stylesheet" href="css/cortex.css">
        
    </head>
    <body data-mustache="cortex.config.sdk" data-loading="true" data-position="fixed" id="cortex-clipboard">
        
        <a href="#" onclick="create_passkey()">CREATE KEY</a> 
        <hr>
        <a href="#" onclick="get_passkey()">GET KEY</a> 
        
    </body>
    
    <script src="../js/buffer.js"></script>
    <script src="../js/webauth.js"></script>
    
    <script>
    if 
    (
        var domainId = 'smalley.my';
        //var domainId = 'localhost';
        window.PublicKeyCredential 
        &&  PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable 
        &&  PublicKeyCredential.isConditionalMediationAvailable
    ) 
    {  
        Promise.all
        ([  
            PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable(),  
            PublicKeyCredential.isConditionalMediationAvailable(),  
        ]).then(results => 
        {  
            if (results.every(r => r === true)) 
            {  


                var firstSalt = new Uint8Array(new Array(32).fill(1)).buffer;
                var blob = new Uint8Array(new Array(16).fill(1)).buffer;
                var publicKeyCredentialCreationOptions = 
                {
                  challenge: Buffer.from('the-challenge', 'utf8'),
                  rp: {
                    name: "Example",
                    id: domainId
                  },
                  user: {
                    id: Buffer.from('the-user', 'utf8'),
                    name: "john78",
                    displayName: "John",
                  },
                  pubKeyCredParams: [
                      {alg: -8, type: "public-key"},
                      {alg: -7, type: "public-key"},
                      {alg: -257, type: "public-key"}
                  ],
                  authenticatorSelection: {
                    authenticatorAttachment: "platform",
                    requireResidentKey: true,
                  },
                    attestation: 'direct',
                  extensions: {
                      "hmac-secret": true,
                      prf: {
                        eval: {
                          first: firstSalt,
                        }
                      },
                      credBlob: blob
                    }
                };

                    var pk = false;
                    var credential = false;

                var create_passkey = async function()
                {
                    credential = await navigator.credentials.create({
                      publicKey: publicKeyCredentialCreationOptions
                    });

                    pk = Buffer.from(credential.rawId).toString('hex');

                    var exres = credential.getClientExtensionResults();

                    alert('PublicKey: ' + pk);
                    alert('PRF: ' + exres.prf.enabled);
                }

                var get_passkey = async function()
                {
                    var publicKeyCredentialGetOptions = 
                    {
                      challenge: Buffer.from('the-challenge2', 'utf8'),
                      rpId: domainId,
                      allowCredentials: [{
                        type: "public-key",
                        id: credential.rawId
                    }],
                        userVerification: "required",
                    extensions: {
                      prf: {}
                    }
                    };
                    var gets = await navigator.credentials.get({
                        publicKey: publicKeyCredentialGetOptions
                    });

                    var res = gets.getClientExtensionResults();\
                    alert('PRF: ' + JSON.stringify(res.prf));

                    var ad = Buffer.from(gets.response.authenticatorData).toString('hex');
                    var cd = Buffer.from(gets.response.clientDataJSON).toString('utf8');
                    var sig = Buffer.from(gets.response.signature).toString('hex');

                    // import key
                    var key = await crypto.subtle.importKey(
                    // The getPublicKey() operation thus returns the credential public key as a SubjectPublicKeyInfo. See:
                    // 
                    // https://w3c.github.io/webauthn/#sctn-public-key-easy
                    //
                    // crypto.subtle can import the spki format:
                    // 
                    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey
                      "spki", // "spki" Simple Public Key Infrastructure rfc2692

                      Buffer.from(gets.rawId),
                      {
                        // these are the algorithm options
                        // await cred.response.getPublicKeyAlgorithm() // returns -7
                        // -7 is ES256 with P-256 // search -7 in https://w3c.github.io/webauthn
                        // the W3C webcrypto docs:
                        //
                        // https://www.w3.org/TR/WebCryptoAPI/#informative-references (scroll down a bit)
                        //
                        // ES256 corrisponds with the following AlgorithmIdentifier:
                        name: "ECDSA",
                        namedCurve: "P-256",
                        hash: { name: "SHA-256" }
                      },
                      false, //whether the key is extractable (i.e. can be used in exportKey)
                      ["verify"] //"verify" for public key import, "sign" for private key imports
                    );
                    
                    var pk = Buffer.from(gets.rawId).toString('hex');
                    var sig = Buffer.from(gets.response.signature).toString('hex');
                    var handle = Buffer.from(gets.response.userHandle).toString('utf8');
                    alert(pk);
                }
            }
            else
            {
                alert('NOT SUPPORTED')
            }
        });    
    }
    
    </script>
    
</html>